<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
        <title>Concurrent programming - 4 - The Digital Cat</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
        <link rel="stylesheet" href="http://www.thedigitalcatonline.com/theme/css/main.css" />
        <link rel="stylesheet" href="http://www.thedigitalcatonline.com/theme/css/custom.css" />
        
        <!-- Pygments CSS START -->
        <link rel="stylesheet" href="http://www.thedigitalcatonline.com/theme/css/pygments/default.css">
        <!-- Pygments CSS END -->

        <link href="http://www.thedigitalcatonline.com/images/TheDigitalCat_favicon_32.png" rel="icon">

        <!-- Google Analytics Universal -->
        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-74364524-1', 'auto');
            ga('send', 'pageview');
        </script>
        <!-- End Google Analytics Universal Code -->

<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Article",
  "name" : "Concurrent programming - 4",
  "author" : {
    "@type" : "Person",
    "name" : "Leonardo Giordani"
  },
  "publisher" : {
    "@type" : "Organization",
    "name" : "The Digital Cat",
    "logo" : {
      "@type" : "ImageObject",
      "url" : "http://www.thedigitalcatonline.com/images/TheDigitalCat_logo_200.jpg",
      "height" : 200,
      "width" : 200
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://www.thedigitalcatonline.com/blog/2013/02/13/concurrent-programming-4/"
  },
  "datePublished" : "13/02/2013",
  "dateModified" : "13/02/2013",
  "image" : "http://www.thedigitalcatonline.com/images/concurrent-programming.jpg",
  "url" : "http://www.thedigitalcatonline.com/blog/2013/02/13/concurrent-programming-4/"
}
</script>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

    <header id="header">
        <a class="logo" href="http://www.thedigitalcatonline.com/category/programming/" title="Programming">All posts in category Programming <i class="fa fa-link"></i></a>
        <div class="align-right">
            
            <a href="http://www.thedigitalcatonline.com/blog/2013/02/06/concurrent-programming-3/"><i class="fa fa-caret-square-left"></i></a>
            
            Concurrent programming #4

            <a href="http://www.thedigitalcatonline.com/blog/2013/02/28/concurrent-programming-5/"><i class="fa fa-caret-square-right"></i></a>

        </div>
    </header>

    <!-- <article class="post"> -->

    <section id="header">
        <header class="main">
            <h1>Concurrent programming - 4</h1>
        </header>
    </section>

    <section id="post-info">
        <div class="align-center">
            <a class="button special small" href="http://www.thedigitalcatonline.com/categories/c/">C</a>            <a class="button special small" href="http://www.thedigitalcatonline.com/categories/operating-systems/">operating systems</a>            <a class="button special small" href="http://www.thedigitalcatonline.com/categories/concurrent-programming/">concurrent programming</a>        </div>

        <div class="align-center">
            By <a href="http://www.thedigitalcatonline.com/authors/leonardo-giordani/">Leonardo Giordani</a>
            <span class="separator">â€¢</span>

            Published on <time datetime="2013-02-13T10:50:00+02:00"> 13/02/2013</time>

        </div>
    </section>

    <section id="content">
        <h2 id="abstract">Abstract<a class="headerlink" href="#abstract" title="Permanent link">&para;</a></h2>
<p>In the past issue, of this series of articles about concurrent programming we started to concern ourselves with the problems of synchronization between processes. In this installment, we will investigate further the subject introducing some structures and functions collectively known as <em>Unix System V IPC</em>.</p>
<h2 id="ipc-interprocess-communication">IPC: InterProcess Communication<a class="headerlink" href="#ipc-interprocess-communication" title="Permanent link">&para;</a></h2>
<p>Communication between processes, either running on the same machine or over a network, is one of the most interesting topics in computer science and, despite its age, new solutions to this problem keep arising. With the widespread availability of Internet access, the subject is now a little shifted towards pure network communication, which represents just a part of the techniques known as <strong>IPC</strong>: InterProcess Communication.</p>
<p>This abbreviation encompasses several different scopes in the field of multiprocessing, the most important ones being <strong>synchronization</strong>, <strong>shared data management</strong> and <strong>messaging</strong>. In this article, we will focus on local IPC, i.e. communication between processes running on the same machine. The underlying concepts and techniques, however, can be easily applied to a network environment too, but they require a layer to manage network communication, which is out of the scope of this series.</p>
<h2 id="more-on-synchronization">More on synchronization<a class="headerlink" href="#more-on-synchronization" title="Permanent link">&para;</a></h2>
<p>As briefly shown in the last article synchronization problems are not only among the most complex issues to solve in computer science, but can also lead to severe malfunctions of our software.</p>
<p>Let's reconsider and formalize the example given in the last post. Say we create two different processes working on the same data. If the two processes just read the same data from memory (or disk) no problems can arise: data are static, and accessing does not change them. So the execution of the two processes is called <strong>consistent</strong>, which highlights that repeated executions or executions spanning a long time will always result in the same system behaviour.</p>
<p>If now one of the processes wants to modify data different situations can come up, depending on the actual timing of the operations. Say we have two processes <code>A</code> and <code>B</code> and an element <code>d</code>; process <code>A</code> increases element <code>d</code> by 1 while process <code>B</code> prints the element value on the screen. In a sort of metalanguage, we could express this situation with the following syntax</p>
<div class="highlight"><pre><span></span>A { d-&gt;d+1 } &amp; B { d-&gt;output }
</pre></div>


<p>where <code>&amp;</code> stands for a concurrent execution; in other words the two processes are not synchronized. One of the possible resulting executions is</p>
<div class="highlight"><pre><span></span>(-) d = 5
(A) d = 6
(B) output = 6
</pre></div>


<p>while the other is</p>
<div class="highlight"><pre><span></span>(-) d = 5
(B) output = 5
(A) d = 6
</pre></div>


<p>As you can see, different timings can lead to different results; let's pretend that element <code>d</code> is the amount of money in your bank account, and you will suddenly realize the importance of the matter. Such a reliance of data on timing or system conditions is known as <strong>data inconsistency</strong>.</p>
<p>As we already described, waiting is a trivial form of synchronization that can solve this problem. However it is as simple as inefficient as it blocks the execution of one process while the other is operating and this happens even if the blocked process is no more operating on shared data. The block is indeed based on the simple assumption that one process could lead to data inconsistency.</p>
<p>It is thus necessary to increase the <strong>granularity</strong> of this block. Granularity is the scope of an action: the higher is the granularity the narrowest is the scope. So we have to restrict the scope of the block, which by now covers the whole process.</p>
<h2 id="system-v-keys">System V keys<a class="headerlink" href="#system-v-keys" title="Permanent link">&para;</a></h2>
<p>A part of the IPC structures introduced by Unix System V is explicitly dedicated to resource identification, the capability of labelling arbitrary objects and limiting access management to them. This is done through the use of the so-called <em>SysV IPC Keys</em>: a <strong>key</strong>, in this context, is a number used to identify univocally an IPC structure. An IPC key can be generated by <code>ftok()</code></p>
<div class="highlight"><pre><span></span><span class="kt">key_t</span> <span class="nf">ftok</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">proj_id</span><span class="p">);</span>
</pre></div>


<p>where <code>pathname</code> is an existing file name with the full path and <code>proj_id</code> is a number without any restriction. It is guaranteed that the returned key is the same for subsequent calls with the same parameters, but it is not guaranteed that different parameters result in different keys: in other words <em>keys are not guaranteed to be unique</em>. Since IPC functions require a key created with <code>ftok()</code> the best solution is to write a small library that keeps track of assigned keys and avoids duplicates.</p>
<h2 id="semaphores-part-1">Semaphores - part 1<a class="headerlink" href="#semaphores-part-1" title="Permanent link">&para;</a></h2>
<p>The idea of traffic light can be profitably borrowed to control access to resources. A <strong>semaphore</strong>, in the IPC world, is a structure capable of containing a positive or null integer and which manages a queue of processes waiting for a particular condition of the semaphore itself.</p>
<p>Despite their simplicity, the power of semaphores is big, thus their correct use is not trivial. We will therefore start writing code without error control, just to focus on the real subject. Please remember that in real world applications, error control code can vary from 40% up to 80% of the total amount, so bear in mind that code without error control is good only for the purpose of understanding concepts.</p>
<p>The first possible use of a semaphore is that of access controller: the value of the semaphore represents the number of processes that can concurrently access the resource. Every time a process access the resource it decrements the value of the semaphore and every time a process releases the resource it increments the value. If the resource is exclusive (that is only one process can access the resource at a time), the maximum value of the semaphore will be 1.</p>
<p>A second use of the semaphore is that of resource counter. The value in this case is the number of resources available to processes, e.g. memory cells, network connections, and so on. As you can easily understand, using a resource is equivalent to locking its access.</p>
<p>Let's consider a practical case where both the uses of semaphores will be useful.</p>
<p>We build a buffer of length L where n processes W1,..., Wn can write to, but from which just one process R can read. Say also that just one process can access the buffer at a given time T. As you can easily understand W processes can write at any time except when the buffer is full while the process R can read at any time except when the buffer is empty.</p>
<p>This buffer could be easily managed in a standard single task environment by declaring 2 flags, the first to signal overflow and the second to signal underflow. We are in a multitasking environment now, so flags declared before the fork operation are not shared between processes (each process has its own copy of the flags, and they are not linked). So we have to use a shared structure, and this is where IPC semaphores take the field.</p>
<p>We can declare three semaphores: the first one will manage access to the buffer while the second and third will keep track of how many elements are in the buffer (later it will become clear why two semaphores are not sufficient).</p>
<p>Given that access to the buffer is exclusive the first semaphore will be a binary one (which value thus will be 0 or 1) while the second and the third will have values linked to the length of the buffer.</p>
<p>In C language the SysV primitive to create a semaphore is</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">semget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nsems</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semflg</span><span class="p">);</span>
</pre></div>


<p>where <code>key</code> is an IPC key created with <code>ftok()</code>, <code>nsems</code> is the number of semaphores we want to create and <code>semflg</code> a set of flags controlling access to the semaphores. Access to IPC structures is ruled by a 12 bit system which is almost identical to the Unix file system access control, but we will not dive into it. As you can also notice <code>semget()</code> manages sets of semaphores, which helps us to keep the code compact.</p>
<p>Let's review the full code to create a semaphore</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/ipc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">key_t</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">semid</span><span class="p">;</span>

  <span class="n">key</span> <span class="o">=</span> <span class="n">ftok</span><span class="p">(</span><span class="s">&quot;/etc/fstab&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

  <span class="cm">/* create a semaphore set with only 1 semaphore: */</span>
  <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Do not compile and execute it by now. As you can see from the <code>#include</code> statements, IPC structures are provided by the operating system itself and not by the standard C library. The key is created by passing to <code>ftok()</code> a file that certainly exists in the system and the PID of the current process. To know more about permission flags check the manual page for <code>semget()</code>.</p>
<p>Let's go on learning to manage and remove semaphores; the primitive used to interact with a semaphore is</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">semnum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="p">...)</span>
</pre></div>


<p>where <code>semid</code> is the semaphore set identifier returned from <code>semget()</code>, <code>semnum</code> the index of the semaphore inside the set and <code>cmd</code> the command you want to run. The value <code>semnum</code> is optional for some commands. Some commands need also an additional argument which type is <code>union semun</code>, defined as</p>
<div class="highlight"><pre><span></span><span class="k">union</span> <span class="n">semun</span> <span class="p">{</span>
 <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>                  <span class="cm">/* value for SETVAL */</span>
 <span class="k">struct</span> <span class="n">semid_ds</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>     <span class="cm">/* buffer for IPC_STAT, IPC_SET */</span>
 <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>    <span class="cm">/* array for GETALL, SETALL */</span>
                           <span class="cm">/* Linux specific part: */</span>
 <span class="k">struct</span> <span class="n">seminfo</span> <span class="o">*</span><span class="n">__buf</span><span class="p">;</span>    <span class="cm">/* buffer for IPC_INFO */</span>
<span class="p">};</span>
</pre></div>


<p>To set the value of a semaphore the command is <code>SETVAL</code> and the value is specified through a <code>union semun</code> variable. To set the value of the first semaphore to 1 we modify the program this way</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/ipc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">key_t</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">semid</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">;</span>

  <span class="n">key</span> <span class="o">=</span> <span class="n">ftok</span><span class="p">(</span><span class="s">&quot;/etc/fstab&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

  <span class="cm">/* create a semaphore set with only 1 semaphore: */</span>
  <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>

  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Last we have to cancel the semaphore releasing the structures needed for its management; this is done by the command <code>IPC_RMID</code>, which removes the semaphore and notifies all processes queued to access it that it has been removed. Let this notification aside for the moment and change the code to remove the semaphore</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/ipc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">key_t</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">semid</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">;</span>

  <span class="n">key</span> <span class="o">=</span> <span class="n">ftok</span><span class="p">(</span><span class="s">&quot;/etc/fstab&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

  <span class="cm">/* create a semaphore set with only 1 semaphore: */</span>
  <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>

  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

  <span class="cm">/* deallocate semaphore */</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Now you can compile and run it. As you can imagine the program seems to do nothing: it just silently creates a semaphore, sets its value and removes it.</p>
<h2 id="semaphores-part-2">Semaphores - part 2<a class="headerlink" href="#semaphores-part-2" title="Permanent link">&para;</a></h2>
<p>Time to use effectively the semaphore: the function that allows to performs operations on a semaphore is </p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">semop</span><span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sembuf</span> <span class="o">*</span><span class="n">sops</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nsops</span><span class="p">);</span>
</pre></div>


<p>where <code>semid</code> is the set identifier, <code>sops</code> an array of operations and <code>nsops</code> the length of the latter. Each operation is declared through a <code>struct sembuf</code></p>
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sembuf</span> <span class="p">{</span>
    <span class="n">ushort</span>  <span class="n">sem_num</span><span class="p">;</span>        <span class="cm">/* semaphore index in array */</span>
             <span class="kt">short</span>   <span class="n">sem_op</span><span class="p">;</span>         <span class="cm">/* semaphore operation */</span>
             <span class="kt">short</span>   <span class="n">sem_flg</span><span class="p">;</span>        <span class="cm">/* operation flags */</span>
<span class="p">};</span>
</pre></div>


<p>For the time being we will always set <code>sem_flg</code> to 0. Operations are always integers and obey the following rules</p>
<ol>
<li>
<p><code>sem_op</code> &lt; 0 This signals that you want to decrease the semaphore value, or in other words lock one of the resources controlled by it. If the value of the semaphore can be decremented without becoming negative it will be and the process running <code>semop()</code> continues. Otherwise, the calling process falls in a sleep status until the semaphore has that number of resources available.</p>
</li>
<li>
<p><code>sem_op</code> = 0 This signals that you are waiting for the semaphore to reach value zero; that is the condition where no resources are available. The calling process falls in a sleep status until that moment.</p>
</li>
<li>
<p><code>sem_op</code> &gt; 0 This signals that you want increase the semaphore value, or in other words release the given number of resources.</p>
</li>
</ol>
<p>Now we can write some code to implement the buffer example previously given. We are going to create 5 processes called W (writers) and a process called R (reader). Each W process tries to lock the resource (the buffer) through a semaphore, and if the buffer is not full, adds an element and releases the lock. The R process tries to lock the buffer, removes an element if available (buffer not empty) and releases the lock.</p>
<p>Since we did not yet talk about shared memory we have to simulate read and write operation, i.e. pretend the operation has been performed. This is necessary since each process has its own memory space and cannot access that of another process. So each process has its own copy of the buffer, and the copies are not linked each other. Later in this series we will talk about techniques that allow sharing memory regions between processes.</p>
<p>As already stated, we need 3 semaphores: the first acts as access controller and its maximum value is 1 while the other two manage overflow and underflow conditions. A single semaphore could not handle both conditions, since <code>semop()</code> acts one-way only.</p>
<p>Let's clarify the latter statement before looking at the code. Say we have a single semaphore to manage over- and underflow conditions, with a value equal to the number of empty spaces in the buffer. Each time a W process fills the buffer it can decrease the semaphore value by one unit until the value reaches 0, which represents the condition of full buffer. This way however the empty buffer condition cannot be managed since the R process can increment the value of the semaphore without any limit. Semaphores, indeed, just control the lower boundary and not the upper one.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/ipc.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/sem.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="cm">/* IPC structures */</span>
  <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="kt">key_t</span> <span class="n">key</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">semid</span><span class="p">;</span>
  <span class="k">union</span> <span class="n">semun</span> <span class="n">arg</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">lock_res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">rel_res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">push</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">pop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">};</span>

  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num_proc</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num_write_actions</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num_read_actions</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Usage: %s &lt;size&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">len</span> <span class="o">=</span> <span class="n">strtol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

  <span class="n">key</span> <span class="o">=</span> <span class="n">ftok</span><span class="p">(</span><span class="s">&quot;/etc/fstab&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

  <span class="cm">/* Create a set with 3 semaphores */</span>
  <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>

  <span class="cm">/* Initialize semaphore #0 to 1 - Resource controller */</span>
  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

  <span class="cm">/* Initialize semaphore #1 to buf_length - Overflow controller */</span>
  <span class="cm">/* Sem value represents free space in buffer */</span>
  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

  <span class="cm">/* Initialize semaphore #2 to buf_length - Underflow controller */</span>
  <span class="cm">/* Sem value represents the number of elements in buffer */</span>
  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

  <span class="cm">/* Fork */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_proc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pid</span><span class="p">){</span>
      <span class="cm">/* Child process code*/</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_write_actions</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
    <span class="n">sleep</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">6</span><span class="p">);</span>

    <span class="cm">/* Try to lock the buffer - sem #0 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;semop:lock_res (write)&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Lock a free cell - sem #1 */</span>
    <span class="cm">/* Push an element - sem #2 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">push</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;---&gt; Child process %d: Element written</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;---&gt; Child process %d: BUFFER FULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* Release the buffer */</span>
    <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rel_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_read_actions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="n">sleep</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">3</span><span class="p">);</span>

    <span class="cm">/* Try to lock the buffer - sem #0 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;semop:lock_res (read)&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Unlock a free cell - sem #1 */</span>
    <span class="cm">/* Pop an element - sem #2 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;&lt;--- Parent process %d: Element read</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;&lt;--- Parent process %d: BUFFER EMPTY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* Release the buffer */</span>
    <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rel_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="cm">/* Destroy semaphores */</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Let us review the most interesting parts of the code.</p>
<div class="highlight"><pre><span></span>  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">lock_res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">rel_res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">push</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">};</span>
  <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">pop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">IPC_NOWAIT</span><span class="p">};</span>
</pre></div>


<p>These four lines of code declare the actions we will use later on the semaphore set. The first two are single actions while the second two are double ones. The first action, <code>lock_res</code>, is used to lock the buffer: as you can see the semaphore number 0 is decremented by 1 and in case of busy resource the strategy is waiting (the last 0 in the action). The second action releases the buffer and is the mirror image of the first one.</p>
<p>The third and fourth actions are specular too; each of them is an array of two actions, the first on the semaphore number 1 and the second on the semaphore number 2; while the first one is incremented the second is decremented and vice versa. The policy is changed from the first two actions: <code>IPC_NOWAIT</code> forces the process to continue execution, in contrast with the previous case, when the process was put on hold.</p>
<div class="highlight"><pre><span></span>  <span class="cm">/* Initialize semaphore #0 to 1 - Resource controller */</span>
  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

  <span class="cm">/* Initialize semaphore #1 to buf_length - Overflow controller */</span>
  <span class="cm">/* Sem value represents free space in buffer */</span>
  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

  <span class="cm">/* Initialize semaphore #2 to buf_length - Underflow controller */</span>
  <span class="cm">/* Sem value represents the number of elements in buffer */</span>
  <span class="n">arg</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
</pre></div>


<p>Next, semaphores must be initialized: as already stated the first one is set to 1, being a binary access controller, the second to the length of the buffer as overflow controller and the third to 0 as underflow controller.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/* Try to lock the buffer - sem #0 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;semop:lock_res (write)&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Lock a free cell - sem #1 */</span>
    <span class="cm">/* Push an element - sem #2 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">push</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;---&gt; Child process %d: Element written</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;---&gt; Child process %d: BUFFER FULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* Release the buffer */</span>
    <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rel_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>


<p>Child process code (a writer) tries first of all to lock the buffer using <code>lock_res</code>; once the control over the resource has been acquired it performs the <code>push</code> action and writes on the standard output a meaningful message. Otherwise, it signals that the buffer is full. The last action it performs is to release the resource through <code>rel_res</code>.</p>
<div class="highlight"><pre><span></span>    <span class="cm">/* Try to lock the buffer - sem #0 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">perror</span><span class="p">(</span><span class="s">&quot;semop:lock_res (read)&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cm">/* Unlock a free cell - sem #1 */</span>
    <span class="cm">/* Pop an element - sem #2 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;&lt;--- Parent process %d: Element read</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;&lt;--- Parent process %d: BUFFER EMPTY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="cm">/* Release the buffer */</span>
    <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rel_res</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>


<p>As you can immediately notice parent process (reader) mimics the behaviour of the child. It lock the buffer, reads some data with the <code>pop</code> action and release the resource.</p>
<p>Try to change the parameters such as the buffer length (on the command line) or the number of cycles performed by parent and child processes to see what happens. </p>
<h2 id="conclusions">Conclusions<a class="headerlink" href="#conclusions" title="Permanent link">&para;</a></h2>
<p>In the next article, we will introduce and deal with atomicity, which is a very important concept in concurrent programming and database systems. We will also introduce a new IPC structure, which has a broad use in distributed systems: message queues.</p>
    </section>

    <section id="related">

        <h1>Part 4 of the Concurrent programming series</h1>
        <div class="box">
            <h5>Previous articles</h5>
            <ul>
                <li><a href="http://www.thedigitalcatonline.com/blog/2013/01/31/concurrent-programming-1/">Concurrent programming - 1</a></li>
                <li><a href="http://www.thedigitalcatonline.com/blog/2013/02/04/concurrent-programming-2/">Concurrent programming - 2</a></li>
                <li><a href="http://www.thedigitalcatonline.com/blog/2013/02/06/concurrent-programming-3/">Concurrent programming - 3</a></li>
            </ul>
        
            <h5>Next articles</h5>
            <ul>
                <li><a href="http://www.thedigitalcatonline.com/blog/2013/02/28/concurrent-programming-5/">Concurrent programming - 5</a></li>
                <li><a href="http://www.thedigitalcatonline.com/blog/2013/04/23/concurrent-programming-6/">Concurrent programming - 6</a></li>
            </ul>
        </div>
    </section>



    <!-- </article> -->

						</div>
					</div>

				<!-- Sidebar -->
					<div id="sidebar">
<div class="inner">
    <!-- Menu -->
        <nav id="menu">
            <header class="major">
                <h2>Menu</h2>
            </header>
<ul>
    <li><a href="http://www.thedigitalcatonline.com/index.html">Homepage</a></li>
    <li><a href="http://www.thedigitalcatonline.com/pages/about.html">About</a></li>
    <li><a href="http://www.thedigitalcatonline.com/archives/">Archives</a></li>
    <li>
        <span class="opener">Categories</span>
        <ul>
            <li><a href="http://www.thedigitalcatonline.com/category/programming/">Programming</a></li>
            <li><a href="http://www.thedigitalcatonline.com/category/projects/">Projects</a></li>
            <li><a href="http://www.thedigitalcatonline.com/category/retro/">Retro</a></li>
        </ul>
    </li>
</ul>        </nav>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Feeds</h2>
            </header>
<ul class="list-clean">
    <li><a href="http://www.thedigitalcatonline.com/atom.xml"><i class="fa fa-rss"></i> All posts</a></li>


    <li><a href="http://www.thedigitalcatonline.com/category/programming/atom.xml"><i class="fa fa-rss"></i> All posts in category: Programming</a></li>
</ul>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Tags</h2>
            </header>
<ul class="list-inline list-clean" id="tags-side">
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/algorithms/">algorithms</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/amiga/">amiga</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/amqp/">AMQP</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/architectures/">architectures</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/assembly/">assembly</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/c/">C</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/clojure/">Clojure</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/compilers/">compilers</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/concurrent-programming/">concurrent programming</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/cryptography/">cryptography</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/decorators/">decorators</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/django/">Django</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/erlang/">Erlang</a>
    </li>
    <li class="tag font-size-1">
        <a href="http://www.thedigitalcatonline.com/categories/functional-programming/">functional programming</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/generators/">generators</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/git/">Git</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/m68000/">M68000</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/metaclasses/">metaclasses</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/metaprogramming/">metaprogramming</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/notebook/">Notebook</a>
    </li>
    <li class="tag font-size-1">
        <a href="http://www.thedigitalcatonline.com/categories/oop/">OOP</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/operating-systems/">operating systems</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/pika/">Pika</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/postage/">Postage</a>
    </li>
    <li class="tag font-size-1">
        <a href="http://www.thedigitalcatonline.com/categories/python/">Python</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/python2/">Python2</a>
    </li>
    <li class="tag font-size-1">
        <a href="http://www.thedigitalcatonline.com/categories/python3/">Python3</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/rabbitmq/">RabbitMQ</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/refactoring/">refactoring</a>
    </li>
    <li class="tag font-size-2">
        <a href="http://www.thedigitalcatonline.com/categories/retroprogramming/">retroprogramming</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/rsa/">RSA</a>
    </li>
    <li class="tag font-size-1">
        <a href="http://www.thedigitalcatonline.com/categories/scala/">Scala</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/ssh/">SSH</a>
    </li>
    <li class="tag font-size-4">
        <a href="http://www.thedigitalcatonline.com/categories/ssl/">SSL</a>
    </li>
    <li class="tag font-size-1">
        <a href="http://www.thedigitalcatonline.com/categories/tdd/">TDD</a>
    </li>
    <li class="tag font-size-1">
        <a href="http://www.thedigitalcatonline.com/categories/testing/">testing</a>
    </li>
    <li class="tag font-size-3">
        <a href="http://www.thedigitalcatonline.com/categories/versioning/">versioning</a>
    </li>
</ul>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Recent posts</h2>
            </header>
<div class="mini-posts">
    <article>
        <a href="http://www.thedigitalcatonline.com/blog/2019/03/04/motorola-68000-addressing-modes/" class="image"><img src="/images/mc68000.jpg" alt="" /></a>
        <p><strong>Motorola 68000: addressing modes</strong> <a href="http://www.thedigitalcatonline.com/blog/2019/03/04/motorola-68000-addressing-modes/">Read</a></p> 
    </article>
    <article>
        <a href="http://www.thedigitalcatonline.com/blog/2019/02/19/exploring-the-amiga-8/" class="image"><img src="/images/exploring-the-amiga-8.jpg" alt="" /></a>
        <p><strong>Exploring the Amiga - Part 8</strong> <a href="http://www.thedigitalcatonline.com/blog/2019/02/19/exploring-the-amiga-8/">Read</a></p> 
    </article>
    <article>
        <a href="http://www.thedigitalcatonline.com/blog/2019/02/19/exploring-the-amiga-7/" class="image"><img src="/images/exploring-the-amiga-7.jpg" alt="" /></a>
        <p><strong>Exploring the Amiga - Part 7</strong> <a href="http://www.thedigitalcatonline.com/blog/2019/02/19/exploring-the-amiga-7/">Read</a></p> 
    </article>
</div>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Get in touch</h2>
            </header>
<p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus, ac varius enim lorem ullamcorper dolore. Proin sed aliquam facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p>
<ul class="contact">
    
    
    
    <li class="fa-twitter"><a href="https://twitter.com/thedigicat">Twitter</a></li>
    
    
    
    
    <li class="fa-github"><a href="https://github.com/TheDigitalCatOnline">GitHub</a></li>
    
</ul>        </section>

    <!-- Footer -->
        <footer id="footer">
            <p class="copyright">Editorial theme by: <a href="https://html5up.net">HTML5 UP</a>.</p>
            <p class="copyright">Cover picture by: <a href="https://pxhere.com/en/photo/1428515">An Min @ pxhere.com</a></p>
        </footer>

</div>					</div>

			</div>

		<!-- Scripts -->
			<script src="http://www.thedigitalcatonline.com/theme/js/jquery.min.js"></script>
			<script src="http://www.thedigitalcatonline.com/theme/js/browser.min.js"></script>
			<script src="http://www.thedigitalcatonline.com/theme/js/breakpoints.min.js"></script>
			<script src="http://www.thedigitalcatonline.com/theme/js/util.js"></script>
			<script src="http://www.thedigitalcatonline.com/theme/js/main.js"></script>

	</body>
</html>