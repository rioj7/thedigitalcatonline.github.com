<!DOCTYPE HTML>
<!--
    Editorial by HTML5 UP
    html5up.net | @ajlkn
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
    <head>
        <title>A game of tokens: solution - Part 1 - The Digital Cat</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <!--[if lte IE 8]><script src="http://blog.thedigitalcatonline.com/theme/js/ie/html5shiv.js"></script><![endif]-->
        <link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/main.css" />

        <!-- Pygments CSS START -->
        <link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/pygments/monokai.css">
        <!-- Pygments CSS END -->

        <link href="http://blog.thedigitalcatonline.com/images/TheDigitalCat_favicon_32.png" rel="icon">

        <!--[if lte IE 9]><link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/ie9.css" /><![endif]-->
        <!--[if lte IE 8]><link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/ie8.css" /><![endif]-->

        <!-- Google Analytics Universal -->
            <script type="text/javascript">
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
                ga('create', 'UA-74364524-1', 'auto');
                ga('send', 'pageview');
            </script>
        <!-- End Google Analytics Universal Code -->
    </head>
    <body>

        <!-- Wrapper -->
            <div id="wrapper">

                <!-- Main -->
                    <div id="main">
                        <div class="inner narrow">

    <header id="header">
        <a href="http://blog.thedigitalcatonline.com/category/programming/" title="Programming">Programming</a>
        <div class="align-right">        
            <a href="#series">A game of tokens</a> part 2/6
        </div>
    </header>
    

    <article class="post">
        <header class="page-header">
            <h1>A game of tokens: solution - Part 1</h1>
        </header>

        <section id="tags" class="align-center">
            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/python/">Python</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/python3/">Python3</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/tdd/">TDD</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/testing/">testing</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/compilers/">compilers</a>        </section>

        <section id="author" class="align-center">
                By
                <a href="http://blog.thedigitalcatonline.com/authors/leonardo-giordani/">Leonardo Giordani</a>
                <span class="separator">â€¢</span>

            Published on
            <time datetime="2017-07-12T10:00:00+01:00"> 12/07/2017</time>

        </section>

        <section id="content">
            <p>This is my solution of the challenge posted <a href="/blog/2017/05/09/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1/">here</a>. As I stressed in that post, this is just <strong>one</strong> possible solution, and not even necessarily the best one. I provide it to show how I managed to solve the tests and how I worked in a TDD way.</p>
<p>Speaking of TDD I realised that I hadn't followed it very strictly, as sometimes I wrote more code than needed, usually forecasting future changes. I do not believe in a inflexible and uncompromising application of rules, so I do not consider this a big issue, as long as the result is a working code that is not blatantly overengineered.</p>
<p>You can find the code for this part in <a href="https://github.com/lgiordani/smallcalc">this repository</a>. The branch called <code>part1</code> contains all the commits explained in this post, and every commit contains both the test(s) and the code that makes the test(s) pass.</p>
<h1>Level 1 - End of file</h1>
<p>The base class to pass the test leverages the provided <code>text_buffer.TextBuffer</code> class, that exposes a <code>load()</code> method, directly composed here to <code>CalcLexer.load()</code>. As the test is not providing a text the easiest solution is just to return the tested token. I extracted <code>get_token()</code> from <code>get_tokens()</code> to have a method that is specifically focused on dealing with the current token. The file <code>smallcalc/calc_lexer.py</code> is then</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">text_buffer</span>
<span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">tok</span> <span class="k">as</span> <span class="n">token</span>

<span class="n">EOF</span> <span class="o">=</span> <span class="s1">&#39;EOF&#39;</span>


<span class="k">class</span> <span class="nc">CalcLexer</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span> <span class="o">=</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">TextBuffer</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">EOF</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span>

    <span class="k">def</span> <span class="nf">get_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()]</span>
</pre></div>


<h1>Level 2 - Single digit integers</h1>
<h2>Lexer</h2>
<p>The two functions <code>get_token()</code> and <code>get_tokens()</code> have to evolve to deal with the new requirements, and to avoid having too much code in a single function I created some private helpers (where "private" has the Python meaning of "please don't use them").</p>
<p>The idea behind <code>get_tokens()</code> is to call <code>get_token()</code> until the <code>EOF</code> token is returned, even though we want the latter to be present in the final result.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_tokens</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="s1">&#39;EOF&#39;</span><span class="p">):</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>

        <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="s1">&#39;EOF&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">tokens</span>
</pre></div>


<p>Then I decided to make <code>get_token()</code> the central hub of my process with the following paradigm: the function tries to extract a specific token and to return it; if the token cannot be extracted, the function tries with the following.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eof</span>

        <span class="n">eol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eol</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eol</span>

        <span class="n">integer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_integer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">integer</span>
</pre></div>


<p>The three helpers shall just try to extract and return the token they have been assigned or None. After some refactoring I came up with three functions (two of them as properties) that simplify common tasks. <code>_current_char</code> and <code>_current_line</code> are just wrappers around two attributes of <code>self._text_storage</code>, while <code>_set_current_token_and_skip()</code> is a bit more complex and ensures that the <code>_current_token</code> is always up to date.</p>
<div class="highlight"><pre><span></span>    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_current_char</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">current_char</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_current_line</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">current_line</span>

    <span class="k">def</span> <span class="nf">_set_current_token_and_skip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">token</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="n">token</span>
        <span class="k">return</span> <span class="n">token</span>
</pre></div>


<p>Once this functions are in place I can write the actual helpers for the token extraction. <code>_process_eol()</code> leverages <code>self._text_storage</code>, which raises an <code>EOLError</code> when the end of line has been reached. So all I need to do is to try to get the current char and return None if nothing happens. In case of <code>EOLError</code> exception I run <code>_set_current_token_and_skip()</code> with the end of line token.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_eol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">EOLError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">newline</span><span class="p">()</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
                <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">EOL</span><span class="p">)</span>
            <span class="p">)</span>
</pre></div>


<p>The helper to process the end of file, <code>_process_eof()</code> is exactly like <code>_process_eol()</code>, using <code>self._current_line</code> and <code>text_buffer.EOFError</code>.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_eof</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current_line</span>
            <span class="k">return</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">EOFError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
                <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">EOF</span><span class="p">)</span>
            <span class="p">)</span>
</pre></div>


<p>At this point of the development the incoming token can only be <code>EOL</code>, <code>EOF</code>, or an integer. So the <code>_process_integer()</code> function doesn't need to return <code>None</code>. So I just create an integer token with the current char and return it.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>


<p>The above methods use two new global variables <code>EOL</code> and <code>INTEGER</code> that are defined at the beginning of the file along with <code>EOF</code></p>
<div class="highlight"><pre><span></span><span class="n">EOL</span> <span class="o">=</span> <span class="s1">&#39;EOL&#39;</span>
<span class="n">INTEGER</span> <span class="o">=</span> <span class="s1">&#39;INTEGER&#39;</span>
</pre></div>


<h2>Parser</h2>
<p><code>CalcParser</code> is the only class that is tested, but forecasting (actually, knowing) that we are going to manage multiple types of nodes, I isolated the code for the <code>IntegerNode</code> in its own class. There is no need yet to abstract things further, however, so <code>IntegerNode</code> doesn't inherit from any other class.</p>
<p>From a pure TDD point of view this is wrong, because I should have written some tests for the <code>IntegerNode</code> class before writing it. The purpose of this exercise, however is to guide you through the creation of a simple compiler, so tests are already given, and I will turn a blind eye on my own exception to the rule (how convenient!).</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">calc_lexer</span> <span class="k">as</span> <span class="n">clex</span>


<span class="k">class</span> <span class="nc">IntegerNode</span><span class="p">:</span>
    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;integer&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="p">}</span>


<span class="k">class</span> <span class="nc">CalcParser</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>


<h2>Visitor</h2>
<p><code>CalcVisitor</code> is by far the simplest class at the moment, as the only node we are managing is the one with an <code>integer</code> type.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>
</pre></div>


<h1>Level 3 - Binary operations: addition</h1>
<h2>Lexer</h2>
<p>The <code>_process_literal()</code> helper does what <code>_process_integer()</code> did before, which is to blindly return a token, this time with the <code>LITERAL</code> type.</p>
<div class="highlight"><pre><span></span><span class="n">LITERAL</span> <span class="o">=</span> <span class="s1">&#39;LITERAL&#39;</span>
</pre></div>


<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_literal</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">LITERAL</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>


<p>The <code>_process_integer()</code> helper, on the other hand, changes to return <code>None</code> when no integer can be parsed, which is easily checked with <code>isdigit()</code>.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_char</span><span class="p">)</span>
        <span class="p">)</span>
</pre></div>


<p>Last, the <code>get_token()</code> method, which adds <code>_process_literal</code> as an additional case.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eof</span>

        <span class="n">eol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eol</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eol</span>

        <span class="n">integer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_integer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">integer</span>

        <span class="n">literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_literal</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">literal</span>
</pre></div>


<h2>Parser</h2>
<p>The parser needs a node that represents the literal, namely <code>LiteralNode</code>, and a node to represent a binary operation, called <code>BinaryNode</code>. To avoid duplicating methods I created the <code>ValueNode</code> class and made both <code>IntegerNode</code> and <code>LiteralNode</code> inherit from that.</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smallcalc</span> <span class="kn">import</span> <span class="n">calc_lexer</span> <span class="k">as</span> <span class="n">clex</span>


<span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>  <span class="c1"># pragma: no cover</span>


<span class="k">class</span> <span class="nc">ValueNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;value_node&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
        <span class="p">}</span>


<span class="k">class</span> <span class="nc">IntegerNode</span><span class="p">(</span><span class="n">ValueNode</span><span class="p">):</span>
    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;integer&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">LiteralNode</span><span class="p">(</span><span class="n">ValueNode</span><span class="p">):</span>

    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;literal&#39;</span>


<span class="k">class</span> <span class="nc">BinaryNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;binary&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>

        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>


<p>The most important change, however, is in <code>CalcParser</code>, where I added the <code>parse_addsymbol()</code> and <code>parse_expression()</code> methods.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcParser</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_addsymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">LiteralNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>


<h2>Visitor</h2>
<p>The visitor has to add the processing code for <code>binary</code> nodes, which assumes the operation can only be a sum, so just needs to visit the left and right nodes.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
            <span class="n">lvalue</span><span class="p">,</span> <span class="n">ltype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>

            <span class="k">return</span> <span class="n">lvalue</span> <span class="o">+</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span>
</pre></div>


<h1>Level 4 - Multi-digit integers</h1>
<p>To provide support for multi-digit integers we just need to change the <code>_process_integer()</code> method of the lexer. The new version makes use of a very simple regular expressions.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">re</span>
</pre></div>


<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">)</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">tail</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="n">token_string</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_current_token_and_skip</span><span class="p">(</span>
            <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">token_string</span><span class="p">))</span>
        <span class="p">)</span>
</pre></div>


<h1>Level 5 - Whitespaces</h1>
<p>To process whitespaces I needed to add a helper called <code>_process_whitespace()</code> with the same structure of the new <code>_process_integer()</code>.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_process_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;\ +&#39;</span><span class="p">)</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">match</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">tail</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()))</span>
</pre></div>


<p>As this time I am not interested in returning whitespace tokens, but I just want to skip them, the helper is added to <code>get_token()</code> without a <code>return</code> statement.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">get_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eof</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eof</span>

        <span class="n">eol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_eol</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">eol</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eol</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_whitespace</span><span class="p">()</span>

        <span class="n">integer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_integer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">integer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">integer</span>

        <span class="n">literal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_literal</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">literal</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">literal</span>
</pre></div>


<h1>Level 6 - Subtraction</h1>
<p>Adding the addition binary operation changed code in the lexer, the parser, and in the visitor. That operation was however considered a generic binary operation, and only the visitor implements the actual <code>+</code> operation. So adding the subtraction works out of the box for the first two stages and requires me to change the visitor only, with a simple <code>if</code> condition on the value of the operator.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
            <span class="n">lvalue</span><span class="p">,</span> <span class="n">ltype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>

            <span class="n">operator</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">+</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">-</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span>
</pre></div>


<h1>Level 7 - Multiple operations</h1>
<p>I made no assumptions on the length of the tokens stream in <code>get_tokens()</code>, so processing multiple tokens comes out of the box inn the lexer.</p>
<p>Adding <code>stash()</code> and <code>pop()</code> is not very complex, as the tests show exactly what we need to save and retrieve. Here I leverage the <code>position</code> attribute and the <code>goto</code> functions of the <code>TextBuffer</code> class.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcLexer</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span> <span class="o">=</span> <span class="n">text_buffer</span><span class="o">.</span><span class="n">TextBuffer</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="p">[</span><span class="o">...</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_current_status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">status</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">status</span><span class="p">[</span><span class="s1">&#39;text_storage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">position</span>
        <span class="n">status</span><span class="p">[</span><span class="s1">&#39;current_token&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span>
        <span class="k">return</span> <span class="n">status</span>

    <span class="k">def</span> <span class="nf">stash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current_status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">status</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_status</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_text_storage</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="o">*</span><span class="n">status</span><span class="p">[</span><span class="s1">&#39;text_storage&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current_token</span> <span class="o">=</span> <span class="n">status</span><span class="p">[</span><span class="s1">&#39;current_token&#39;</span><span class="p">]</span>
</pre></div>


<p>Once <code>stash()</code> and <code>pop()</code> are in place implementing <code>peek_token()</code> is trivial</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">peek_token</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stash</span><span class="p">()</span>
        <span class="n">token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">token</span>
</pre></div>


<p>Finally, <code>peek_token()</code> allows me to add support for multiple expressions in the parser.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">while</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

            <span class="n">left</span> <span class="o">=</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

            <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">left</span>
</pre></div>


<h1>Final words</h1>
<p>Again, it is worth mentioning that this solution of mine is just one of the possible ones, not the <strong>correct</strong> one. If your code passes the tests it is correct; it can be ugly, overengineered, slow, but definitely correct. I hope that reading my solution helped you better understand the underlying concepts of lexer, parser, and visitor. Feel free to get in touch if you want to discuss your solution or if you have questions about the code I posted here.</p>
<h1>Updates</h1>
<p>2017-12-24: As mentioned in the updates section of the previous post, Victor Uriarte spotted an error in <code>parse_expression()</code>. The previous version was building a right-growing tree instead of a left-growing one. The current version is correct and corretly handles cases like the one that Victor pointed out in the <a href="https://github.com/lgiordani/smallcalc/issues/4">issue</a> he posted. Thanks Victor!</p>
<h1>Feedback</h1>
<p>Feel free to use <a href="https://plus.google.com/u/0/111444750762335924049">the blog Google+ page</a> to comment the post. Feel free to reach me on <a href="https://twitter.com/thedigicat">Twitter</a> if you have questions. The <a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
        </section>

<section id="related-posts">
    <h2>Related Posts</h2>
    <div class="box">
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-solution-part-3/">A game of tokens: solution - Part 3</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-3/">A game of tokens: write an interpreter in Python with TDD - Part 3</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/17/a-game-of-tokens-solution-part-2/">A game of tokens: solution - Part 2</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/">A game of tokens: write an interpreter in Python with TDD - Part 2</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/05/09/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1/">A game of tokens: write an interpreter in Python with TDD - Part 1</a></li>
        </ul>
    </div>
</section>
<section id="series">
    <h2>Part 2 of the A game of tokens series</h2>
    <div class="box">
        <h5>Previous articles</h5>
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/05/09/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1/">A game of tokens: write an interpreter in Python with TDD - Part 1</a></li>
        </ul>
    
        <h5>Next articles</h5>
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/">A game of tokens: write an interpreter in Python with TDD - Part 2</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/17/a-game-of-tokens-solution-part-2/">A game of tokens: solution - Part 2</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-3/">A game of tokens: write an interpreter in Python with TDD - Part 3</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-solution-part-3/">A game of tokens: solution - Part 3</a></li>
        </ul>
    </div>
</section>
    </article>


                        </div>
                    </div>

                <!-- Sidebar -->
                    <div id="sidebar">
<div class="inner">
    <!-- Menu -->
    <nav id="menu">
        <header class="major">
            <h2>Menu</h2>
        </header>
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/">Homepage</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/pages/about.html">About</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/archives/">Archives</a></li>
        </ul>
    </nav>

    <!-- Feeds -->
<section>
    <header class="major">
        <h2>Feeds</h2>
    </header>
    <ul class="list-clean">
        <li><a href="http://blog.thedigitalcatonline.com/atom.xml"><i class="fa fa-rss"></i> All posts</a></li>


        <li><a href="http://blog.thedigitalcatonline.com/category/programming/atom.xml"><i class="fa fa-rss"></i> All posts in category: Programming</a></li>
    </ul>
</section>
    <!-- Recent posts -->
<section>
    <header class="major">
        <h2>Recent posts</h2>
    </header>
    <div class="mini-posts">
        <article>
            Exploring the Amiga - Part 2
            <a href="http://blog.thedigitalcatonline.com/blog/2018/05/28/exploring-the-amiga-2/"> Read</a>
        </article>
        <article>
            Exploring the Amiga - Part 1
            <a href="http://blog.thedigitalcatonline.com/blog/2018/05/28/exploring-the-amiga-1/"> Read</a>
        </article>
        <article>
            Public key cryptography: RSA keys
            <a href="http://blog.thedigitalcatonline.com/blog/2018/04/25/rsa-keys/"> Read</a>
        </article>
        <article>
            Introduction to hashing
            <a href="http://blog.thedigitalcatonline.com/blog/2018/04/06/introduction-to-hashing/"> Read</a>
        </article>
        <article>
            A game of tokens: solution - Part 3
            <a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-solution-part-3/"> Read</a>
        </article>
    </div>
</section>
    <!-- Tags -->
<section>
    <header class="major">
        <h2>Tags</h2>
    </header>
    <ul class="list-inline list-clean" id="tags-side">
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/algorithms/">algorithms</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/amiga/">amiga</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/amqp/">AMQP</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/architectures/">architectures</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/assembly/">assembly</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/c/">C</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/clojure/">Clojure</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/compilers/">compilers</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/concurrent-programming/">concurrent programming</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/cryptography/">cryptography</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/decorators/">decorators</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/django/">Django</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/erlang/">Erlang</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/functional-programming/">functional programming</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/generators/">generators</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/git/">Git</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/metaclasses/">metaclasses</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/metaprogramming/">metaprogramming</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/notebook/">Notebook</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/oop/">OOP</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/operating-systems/">operating systems</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/pika/">Pika</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/postage/">Postage</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/python/">Python</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/python2/">Python2</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/python3/">Python3</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/rabbitmq/">RabbitMQ</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/refactoring/">refactoring</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/retroprogramming/">retroprogramming</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/rsa/">RSA</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/scala/">Scala</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/ssh/">SSH</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/ssl/">SSL</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/tdd/">TDD</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/testing/">testing</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/versioning/">versioning</a>
        </li>
    </ul>
</section>
    <!-- Section -->
<section>
    <header class="major">
        <h2>Get in touch</h2>
    </header>
    <ul class="list-clean" id="social">
        
        
        
        <li class="list-item-spaced"><a href="https://twitter.com/thedigicat"><i class="fa fa-twitter-square fa-lg"></i> Twitter</a></li>
        
        
        
        
        <li class="list-item-spaced"><a href="https://plus.google.com/u/0/111444750762335924049"><i class="fa fa-google-plus-square fa-lg"></i> Google+</a></li>
        
        
        
        
        <li class="list-item-spaced"><a href="https://github.com/TheDigitalCatOnline"><i class="fa fa-github-square fa-lg"></i> GitHub</a></li>
        
    </ul>
</section>
    <!-- Footer -->
    <footer id="footer">
        <p class="copyright">Editorial theme by: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>

</div>                    </div>

            </div>

        <!-- Scripts -->
            <script src="http://blog.thedigitalcatonline.com/theme/js/jquery.min.js"></script>
            <script src="http://blog.thedigitalcatonline.com/theme/js/skel.min.js"></script>
            <script src="http://blog.thedigitalcatonline.com/theme/js/util.js"></script>
            <!--[if lte IE 8]><script src="http://blog.thedigitalcatonline.com/theme/js/ie/respond.min.js"></script><![endif]-->
            <script src="http://blog.thedigitalcatonline.com/theme/js/main.js"></script>

    </body>
</html>