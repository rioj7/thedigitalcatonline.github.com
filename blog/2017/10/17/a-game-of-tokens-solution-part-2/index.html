<!DOCTYPE HTML>
<!--
    Editorial by HTML5 UP
    html5up.net | @ajlkn
    Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
    <head>
        <title>A game of tokens: solution - Part 2 - The Digital Cat</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <!--[if lte IE 8]><script src="http://blog.thedigitalcatonline.com/theme/js/ie/html5shiv.js"></script><![endif]-->
        <link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/main.css" />

        <!-- Pygments CSS START -->
        <link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/pygments/monokai.css">
        <!-- Pygments CSS END -->

        <link href="http://blog.thedigitalcatonline.com/images/TheDigitalCat_favicon_32.png" rel="icon">

        <!--[if lte IE 9]><link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/ie9.css" /><![endif]-->
        <!--[if lte IE 8]><link rel="stylesheet" href="http://blog.thedigitalcatonline.com/theme/css/ie8.css" /><![endif]-->
    </head>
    <body>

        <!-- Wrapper -->
            <div id="wrapper">

                <!-- Main -->
                    <div id="main">
                        <div class="inner narrow">

    <header id="header">
        <a href="http://blog.thedigitalcatonline.com/category/programming/" title="Programming">Programming</a>
        <div class="align-right">        
            <a href="#series">A game of tokens</a> part 4/6
        </div>
    </header>
    

    <article class="post">
        <header class="page-header">
            <h1>A game of tokens: solution - Part 2</h1>
        </header>

        <section id="tags" class="align-center">
            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/python/">Python</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/python3/">Python3</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/tdd/">TDD</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/testing/">testing</a>            <a class="button special small" href="http://blog.thedigitalcatonline.com/categories/compilers/">compilers</a>        </section>

        <section id="author" class="align-center">
                By
                <a href="http://blog.thedigitalcatonline.com/authors/leonardo-giordani/">Leonardo Giordani</a>
                <span class="separator">â€¢</span>

            Published on
            <time datetime="2017-10-17T13:00:00+01:00"> 17/10/2017</time>

        </section>

        <section id="content">
            <p>Here we are, with my solution to the second part of "A Game of Tokens", aka how to write a simple interpreter in Python and survive to tell the tale. The second part of the challenge can be found <a href="/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/">here</a>. Again, it is never repeated too many times, this is my personal solution. Your solution can be different, and if all the test pass it is correct!</p>
<p>You can find the code for this part in <a href="https://github.com/lgiordani/smallcalc">this repository</a>. The branch called <code>part2</code> contains all the commits explained in this post, and every commit contains both the test(s) and the code that makes the test(s) pass.</p>
<h1>Level 8 - Multiplication and division</h1>
<h2>Lexer</h2>
<p>The tests we added for the lexer already pass. This is not surprising, as the lexer is designed to return everything it doesn't know as a <code>LITERAL</code> (<code>smallcalc/calc_lexer.py:119</code>). As we already instructed the lexer to skip spaces the new operators are happily digested. I decided for this project not to assign operators a specific token, so from this point of view our lexer is pretty open and could already understand instructions like <code>3 $ 5</code> or <code>7 : 9</code>, even though they do not have a mathematical meaning.</p>
<h2>Parser</h2>
<p>The parser is not so merciful, and the two new tests do not pass. We are explicitly calling a <code>parse_term()</code> method that is not defined, so a success would have been very worrying. In these two tests <code>parse_term()</code> is called explicitly and there is no relationship with the other <code>parse_*</code> methods, so we can implement it as a stand-alone processing.</p>
<p>We know that a <code>term</code> is an operation between two integers, so we can follow what we did with <code>parse_expression()</code>. The first thing we do is to parse the first integer, then we peek the next token and we decide what to do. If the token is a <code>LITERAL</code> we suppose it is the operation, otherwise we probably hit the end of the file and we will just return the previously read integer. The second element may be a simple integer or another multiplication or division, so we recursively call <code>parse_term()</code> and return a <code>BinaryNode</code> with the result.</p>
<p>[Note: I notice that the <code>parse_addsymbol()</code> could be now named <code>parse_literal()</code> but this wasn't done when I prepared the source code. Regardless of the name, however, what this method does is to just pack a literal in a <code>LiteralNode</code> and return it.]</p>
<p>The whole parser is now the following</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcParser</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_addsymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">LiteralNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_term</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>


<h2>Visitor</h2>
<p>The visitor was instructed to deal with sums and subtractions, and it treats everything is not the former as the latter. This is why the new tests give as results <code>1</code> and <code>7</code>. We just need to extend the <code>if</code> statement to include the new operations</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
            <span class="n">lvalue</span><span class="p">,</span> <span class="n">ltype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>

            <span class="n">operator</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">+</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
            <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">-</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
            <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">*</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
            <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">//</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
</pre></div>


<p>Now we have a pretty simple but working calculator! Enjoy the <code>cli.py</code>, as YOU did it this time! I rememberI was pretty excited the first time I run a command line calculator done by me. But hold tight, because you are going to learn and implement much more!</p>
<h1>Level 9 - Mixing operators</h1>
<p>Ouch! It looks like putting multiplications and sums in the same line is not really working. As you may recall we didn't link <code>parse_term()</code> with the other methods, and we use a generic function to treat literals. This works in principle, but doesn't consider operator precedence.</p>
<p>The current output of the parser is</p>
<div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">2</span>
  <span class="p">},</span>
  <span class="s2">&quot;operator&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
    <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;*&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="s2">&quot;left&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
      <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">3</span>
    <span class="p">},</span>
    <span class="s2">&quot;operator&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;literal&quot;</span><span class="p">,</span>
      <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;+&quot;</span>
    <span class="p">},</span>
    <span class="s2">&quot;right&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;integer&quot;</span><span class="p">,</span>
      <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">4</span>
    <span class="p">},</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;binary&quot;</span>
  <span class="p">},</span>
  <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;binary&quot;</span>
<span class="p">}</span>
</pre></div>


<p>As you can clearly see the parser recognised the multiplication operator, but then returns a nested sum (the oputput of a recursive call of <code>parse_term()</code>). This gives the sum a greater precedence that that of the sum, which is against the mathematical rules we want to follow here. <code>2 * 3 + 4</code> shall be considered <code>(2 * 3) + 4</code> and not <code>2 + (3 * 4)</code>.</p>
<p>To fix this we have to rework <code>parse_term()</code>. First of all it shall accept only the <code>*</code> and <code>/</code> operators, then it shall return the left part if it finds a different literal. Even <code>parse_expression()</code> shall change a bit: the first thing to do is to call <code>parse_term()</code> instead of <code>parse_integer()</code> and then to return the left part.</p>
<p>The new code is then</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">]:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_term</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span>

    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_term</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span>
</pre></div>


<p>Let's see what happens parsing <code>2 * 3 + 4</code>. The test calls <code>parse_expression()</code> which tries immediately to run <code>parse_term()</code>. This latter recognises <code>2</code> and <code>*</code>, so it calls itself recursively just before the <code>3</code> and returns the binary node. This means that the multiplication is the first operation we return, the one with higher precedence. The recursive call recognises <code>3</code> but then doesn't know what to do with <code>+</code> as we specifically consider only <code>*</code> and <code>/</code>, so it just returns the integer value. Back to <code>parse_expression()</code>, then the variable <code>left</code> will contain the binary node that represents <code>2 * 3</code>. The function will then finish adding the binary node for the sum.</p>
<p>Take your time to understand the mechanism, perhaps trying with different operations like <code>2 + 4 * 6 - 8</code>, which should return <code>18</code>.</p>
<h1>Level 10 - Parentheses</h1>
<p>Let's have some Lisp time here and introduce parenthesis. As happened for the new mathematical operators, parenthesis are already accepted by the lexer as simple literals, so the first test passes without any change in the code. The parser complains, however, as it always expects an integer (<code>smallcalc/calc_parser.py:76</code>).</p>
<p>As I suggested in the post my idea is to introduce a method that parses a so-called <em>factor</em>, which can either be an integer of an expression between parenthesis.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcParser</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_addsymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">LiteralNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">expression</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>
</pre></div>


<p>Then <code>parse_term()</code> method now has to call <code>parse_factor()</code></p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_term</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_factor</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">]:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_term</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span>
</pre></div>


<p>And last we need to slightly change <code>parse_expression()</code> introducing a check on the literal token value. This happens because I decided to identify everything with a literal, so the method has to rule out every literal it is not interested to manage. If you introduce specific tokens for operations, parenthesis, etc., this change is not required (but you won't use <code>clex.LITERAL</code> at that point).</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_term</span><span class="p">()</span>

        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">]:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">BinaryNode</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">left</span>
</pre></div>


<h1>Level 11 - Priorities</h1>
<p>Another feature that comes for free with the previous changes, as the first thing that <code>parse_expression()</code> does is to run <code>parse_term()</code>, and the first thing the latter does is to run <code>parse_factor()</code>, which in turn manages expressions between parenthesis. If the expression is enclosed between parenthesis the <code>parse_factor()</code> method doesn't call <code>parse_expression()</code> and just returns the integer.</p>
<h1>Level 12 - Unary operators</h1>
<p>The minus unary operator uses a literal that we already manage in the lexer, so there is nothing to do there. The first test I gave you checks if the parser can process a factor in the form <code>-5</code>.</p>
<p>The current implementation of <code>parse_factor()</code> processes either an expression enclosed between parenthesis or an integer, and actually the test doesn't pass, complaining against the minus sign not being a valid integer with base 10. The solution is pretty straightforward, as it is enough to add another <code>if</code> that manages the minus sign. When we encounter such a sign, however, wwe have to return a different type of node, as the test states, so we also have to introduce the relative class.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UnaryNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>

    <span class="n">node_type</span> <span class="o">=</span> <span class="s1">&#39;unary&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operator</span><span class="p">,</span> <span class="n">content</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operator</span> <span class="o">=</span> <span class="n">operator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="n">content</span>

    <span class="k">def</span> <span class="nf">asdict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_type</span><span class="p">,</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">operator</span><span class="o">.</span><span class="n">asdict</span><span class="p">(),</span>
            <span class="s1">&#39;content&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">content</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">CalcParser</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">parse_addsymbol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">LiteralNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">IntegerNode</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_factor</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">UnaryNode</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">expression</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>
</pre></div>


<p>The second test passes automatically because <code>parse_factor()</code> intercepts the <code>-</code> literal before the <code>(</code> one.</p>
<p>The visitor, then, has to be updated with the new type of <code>unary</code> node. The new visitor is then</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CalcVisitor</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;integer&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;unary&#39;</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">cvalue</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span> <span class="n">cvalue</span><span class="p">,</span> <span class="n">ctype</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;binary&#39;</span><span class="p">:</span>
            <span class="n">lvalue</span><span class="p">,</span> <span class="n">ltype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">])</span>
            <span class="n">rvalue</span><span class="p">,</span> <span class="n">rtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">])</span>

            <span class="n">operator</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">+</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
            <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">-</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
            <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">*</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
            <span class="k">elif</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lvalue</span> <span class="o">//</span> <span class="n">rvalue</span><span class="p">,</span> <span class="n">ltype</span>
</pre></div>


<p>Now the unary plus is easy to sort out, as we just need to take it into account in <code>parse_factor()</code> along with the unary minus.</p>
<div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">parse_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">next_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">peek_token</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">]:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_addsymbol</span><span class="p">()</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_factor</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">UnaryNode</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="n">factor</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">next_token</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span> <span class="ow">and</span> <span class="n">next_token</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">get_token</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">expression</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_integer</span><span class="p">()</span>
</pre></div>


<p>And the visitor is missing a single return after the <code>if</code> statement that deals with the unary minus.</p>
<div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;unary&#39;</span><span class="p">:</span>
            <span class="n">operator</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">cvalue</span><span class="p">,</span> <span class="n">ctype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="s1">&#39;content&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">operator</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span> <span class="n">cvalue</span><span class="p">,</span> <span class="n">ctype</span>

            <span class="k">return</span> <span class="n">cvalue</span><span class="p">,</span> <span class="n">ctype</span>
</pre></div>


<h2>Final words</h2>
<p>Well, we have a pretty decent calculator now, don't we? Stay tuned, as in the next instalment we will explore variables and postfix operators. Get in touch if you want to discuss your solution or if you have questions about the code I posted here.</p>
<h2>Feedback</h2>
<p>Feel free to use <a href="https://plus.google.com/u/0/111444750762335924049">the blog Google+ page</a> to comment the post. Feel free to reach me on <a href="https://twitter.com/thedigicat">Twitter</a> if you have questions. The <a href="http://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
        </section>

<section id="related-posts">
    <h2>Related Posts</h2>
    <div class="box">
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/05/09/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1/">A game of tokens: write an interpreter in Python with TDD - Part 1</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/">A game of tokens: write an interpreter in Python with TDD - Part 2</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-3/">A game of tokens: write an interpreter in Python with TDD - Part 3</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/07/12/a-game-of-tokens-solution-part-1/">A game of tokens: solution - Part 1</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-solution-part-3/">A game of tokens: solution - Part 3</a></li>
        </ul>
    </div>
</section>
<section id="series">
    <h2>Part 4 of the A game of tokens series</h2>
    <div class="box">
        <h5>Previous articles</h5>
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/05/09/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1/">A game of tokens: write an interpreter in Python with TDD - Part 1</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/07/12/a-game-of-tokens-solution-part-1/">A game of tokens: solution - Part 1</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/">A game of tokens: write an interpreter in Python with TDD - Part 2</a></li>
        </ul>
    
        <h5>Next articles</h5>
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-3/">A game of tokens: write an interpreter in Python with TDD - Part 3</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-solution-part-3/">A game of tokens: solution - Part 3</a></li>
        </ul>
    </div>
</section>
    </article>


                        </div>
                    </div>

                <!-- Sidebar -->
                    <div id="sidebar">
<div class="inner">
    <!-- Menu -->
    <nav id="menu">
        <header class="major">
            <h2>Menu</h2>
        </header>
        <ul>
            <li><a href="http://blog.thedigitalcatonline.com/">Homepage</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/pages/about.html">About</a></li>
            <li><a href="http://blog.thedigitalcatonline.com/archives/">Archives</a></li>
        </ul>
    </nav>

    <!-- Feeds -->
<section>
    <header class="major">
        <h2>Feeds</h2>
    </header>
    <ul class="list-clean">
        <li><a href="http://blog.thedigitalcatonline.com/atom.xml"><i class="fa fa-rss"></i> All posts</a></li>


        <li><a href="http://blog.thedigitalcatonline.com/category/programming/atom.xml"><i class="fa fa-rss"></i> All posts in category: Programming</a></li>
    </ul>
</section>
    <!-- Recent posts -->
<section>
    <header class="major">
        <h2>Recent posts</h2>
    </header>
    <div class="mini-posts">
        <article>
            A game of tokens: solution - Part 3
            <a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-solution-part-3/"> Read</a>
        </article>
        <article>
            A game of tokens: write an interpreter in Python with TDD - Part 3
            <a href="http://blog.thedigitalcatonline.com/blog/2017/10/31/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-3/"> Read</a>
        </article>
        <article>
            A game of tokens: solution - Part 2
            <a href="http://blog.thedigitalcatonline.com/blog/2017/10/17/a-game-of-tokens-solution-part-2/"> Read</a>
        </article>
        <article>
            A game of tokens: write an interpreter in Python with TDD - Part 2
            <a href="http://blog.thedigitalcatonline.com/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/"> Read</a>
        </article>
        <article>
            Refactoring with tests in Python: a practical example
            <a href="http://blog.thedigitalcatonline.com/blog/2017/07/21/refactoring-with-test-in-python-a-practical-example/"> Read</a>
        </article>
    </div>
</section>
    <!-- Tags -->
<section>
    <header class="major">
        <h2>Tags</h2>
    </header>
    <ul class="list-inline list-clean" id="tags-side">
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/amqp/">AMQP</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/architectures/">architectures</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/c/">C</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/clojure/">Clojure</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/compilers/">compilers</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/concurrent-programming/">concurrent programming</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/decorators/">decorators</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/django/">Django</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/erlang/">Erlang</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/functional-programming/">functional programming</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/generators/">generators</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/git/">Git</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/metaclasses/">metaclasses</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/metaprogramming/">metaprogramming</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/notebook/">Notebook</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/oop/">OOP</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/operating-systems/">operating systems</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/pika/">Pika</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/postage/">Postage</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/python/">Python</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/python2/">Python2</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/python3/">Python3</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/rabbitmq/">RabbitMQ</a>
        </li>
        <li class="tag-4">
            <a href="http://blog.thedigitalcatonline.com/categories/refactoring/">refactoring</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/scala/">Scala</a>
        </li>
        <li class="tag-1">
            <a href="http://blog.thedigitalcatonline.com/categories/tdd/">TDD</a>
        </li>
        <li class="tag-2">
            <a href="http://blog.thedigitalcatonline.com/categories/testing/">testing</a>
        </li>
        <li class="tag-3">
            <a href="http://blog.thedigitalcatonline.com/categories/versioning/">versioning</a>
        </li>
    </ul>
</section>
    <!-- Section -->
<section>
    <header class="major">
        <h2>Get in touch</h2>
    </header>
    <ul class="list-clean" id="social">
        
        
        
        <li class="list-item-spaced"><a href="https://twitter.com/thedigicat"><i class="fa fa-twitter-square fa-lg"></i> Twitter</a></li>
        
        
        
        
        <li class="list-item-spaced"><a href="https://plus.google.com/u/0/111444750762335924049"><i class="fa fa-google-plus-square fa-lg"></i> Google+</a></li>
        
        
        
        
        <li class="list-item-spaced"><a href="https://github.com/TheDigitalCatOnline"><i class="fa fa-github-square fa-lg"></i> GitHub</a></li>
        
    </ul>
</section>
    <!-- Footer -->
    <footer id="footer">
        <p class="copyright">Editorial theme by: <a href="https://html5up.net">HTML5 UP</a>.</p>
    </footer>

</div>                    </div>

            </div>

        <!-- Scripts -->
            <script src="http://blog.thedigitalcatonline.com/theme/js/jquery.min.js"></script>
            <script src="http://blog.thedigitalcatonline.com/theme/js/skel.min.js"></script>
            <script src="http://blog.thedigitalcatonline.com/theme/js/util.js"></script>
            <!--[if lte IE 8]><script src="http://blog.thedigitalcatonline.com/theme/js/ie/respond.min.js"></script><![endif]-->
            <script src="http://blog.thedigitalcatonline.com/theme/js/main.js"></script>

    </body>
</html>