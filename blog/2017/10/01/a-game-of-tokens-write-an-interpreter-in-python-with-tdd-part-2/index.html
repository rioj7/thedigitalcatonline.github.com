<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
        <title>A game of tokens: write an interpreter in Python with TDD - Part 2 - The Digital Cat</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,400italic,600italic|Roboto+Slab:400,700">

        <link rel="stylesheet" href="/theme/css/main.min.css?95cd4e15">

        
        <link href="/images/global/favicon.jpg" rel="icon">

        <!-- Google Analytics Universal -->
        <script type="text/javascript">
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-74364524-1', 'auto');
            ga('send', 'pageview');
        </script>
        <!-- End Google Analytics Universal Code -->

<script type="application/ld+json">
{
  "@context" : "https://schema.org",
  "@type" : "Article",
  "name" : "A game of tokens: write an interpreter in Python with TDD - Part 2",
  "author" : {
    "@type" : "Person",
    "name" : "Leonardo Giordani"
  },
  "publisher" : {
    "@type" : "Organization",
    "name" : "The Digital Cat",
    "logo" : {
      "@type" : "ImageObject",
      "url" : "https://www.thedigitalcatonline.com/images/global/logo_200.jpg",
      "height" : 200,
      "width" : 200
    }
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.thedigitalcatonline.com/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/"
  },
  "datePublished" : "01/10/2017",
  "dateModified" : "01/10/2017",
  "image" : "https://www.thedigitalcatonline.com/images/a-game-of-tokens.jpg",
  "url" : "https://www.thedigitalcatonline.com/blog/2017/10/01/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-2/"
}
</script>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">
						<div class="inner">

    <header id="header">
        <a class="logo" href="/category/programming/" title="Programming">All posts in category Programming <i class="fa fa-link"></i></a>
        <div class="align-right">
            
            <a href="/blog/2017/07/12/a-game-of-tokens-solution-part-1/"><i class="fa fa-caret-square-left"></i></a>
            
            A game of tokens #3

            <a href="/blog/2017/10/17/a-game-of-tokens-solution-part-2/"><i class="fa fa-caret-square-right"></i></a>

        </div>
    </header>

    <!-- <article class="post"> -->

    <section id="header">
        <header class="main">
            <h1>A game of tokens: write an interpreter in Python with TDD - Part 2</h1>
        </header>
    </section>

    <section id="post-info">
        <div class="align-center">
            <a class="button small" href="/categories/python/">Python</a>            <a class="button small" href="/categories/python3/">Python3</a>            <a class="button small" href="/categories/tdd/">TDD</a>            <a class="button small" href="/categories/testing/">testing</a>            <a class="button small" href="/categories/compilers/">compilers</a>        </div>

        <div class="align-center">
            By Leonardo Giordani
            <span class="separator">â€¢</span>

            Published on <time datetime="2017-10-01T15:00:00+01:00"> 01/10/2017</time>

        </div>
    </section>

    <section id="content">
        <p>My solution to the <a href="https://www.thedigitalcatonline.com/blog/2017/05/09/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1/">first part</a> can be found <a href="https://github.com/lgiordani/smallcalc/tree/part1">here</a>, and a discussion about the code has been published <a href="https://www.thedigitalcatonline.com/blog/2017/07/12/a-game-of-tokens-solution-part-1/">here</a> Remember that this is only one possible solution, and that giving you the tests I already biased the whole project towards my implementation of choice, so feel free to experiment on your own!</p>
<p>In this instalment I'll give you new tests that will guide you through the implementation of a decent calculator, with multiplication, division, parenthesis, and unary operators. I will reference the structure I used in my solution, but you mileage may vary, so feel free to ignore the comments or the suggested solutions in case your code is different.</p>
<h1 id="level-8-multiplication-and-division">Level 8 - Multiplication and division<a class="headerlink" href="#level-8-multiplication-and-division" title="Permanent link">&para;</a></h1>
<p><em>"They're coming outta the walls. They're coming outta the goddamn walls."</em></p>
<p>As you remember from the previous post our interpreter is made of three different components, the lexer, the parser, and the visitor. So, to implement the missing basic operations, multiplication and division, we need to start with the lexer and ensure that it understands the traditional symbols <code>*</code> and <code>/</code></p>
<h2 id="lexer">Lexer<a class="headerlink" href="#lexer" title="Permanent link">&para;</a></h2>
<p>Put the following tests in the <code>tests/test_calc_lexer.py</code> file</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_get_tokens_understands_multiplication</span><span class="p">():</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="n">l</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;3 * 5&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">l</span><span class="o">.</span><span class="n">get_tokens</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">INTEGER</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">INTEGER</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">EOL</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">EOF</span><span class="p">)</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">test_get_tokens_understands_division</span><span class="p">():</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="n">l</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;3 / 5&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">l</span><span class="o">.</span><span class="n">get_tokens</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">INTEGER</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">INTEGER</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">EOL</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">EOF</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>


<p>Do the tests fail? Why? Please remember that when tests pass without requiring any code change you have to ask yourself "Why do they pass?", and be sure that you understood the answer before going further.</p>
<h2 id="parser">Parser<a class="headerlink" href="#parser" title="Permanent link">&para;</a></h2>
<p>Now that the lexer understands the symbols we can start considering the parser. The parser has to output a sensible structure that represents the new operations, which is not different from what it outputs for the sum and the difference. Add the following tests to <code>tests/test_calc_parser.py</code></p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_parse_term</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;2 * 3&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_term</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
        <span class="p">},</span>
        <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
        <span class="p">},</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">test_parse_term_with_multiple_operations</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;2 * 3 / 4&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_term</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
            <span class="p">},</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
            <span class="p">},</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">4</span>
        <span class="p">},</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;/&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>This time you should have some failures, so go and edit the <code>CalcParser</code> class in order to pass the tests. As the two new binary operations are at this level the same as sum and difference you <em>could</em> change the <code>parse_expression()</code> method (try it!). This will however make things harder later when we will prioritise operations (multiplications have to be performed before sums), so my advice is to introduce a <code>parse_term()</code> method in the parser.</p>
<h2 id="visitor">Visitor<a class="headerlink" href="#visitor" title="Permanent link">&para;</a></h2>
<p>Now it's the visitor's turn, where the syntax tree gets analysed and actually executed. Add the following tests to the <code>tests/test_calc_visitor.py</code> file and then make them pass changing the <code>CalcVisitor</code> class accordingly.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_visitor_term_multiplication</span><span class="p">():</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">5</span>
        <span class="p">},</span>
        <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">4</span>
        <span class="p">},</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">cvis</span><span class="o">.</span><span class="n">CalcVisitor</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_visitor_term_division</span><span class="p">():</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">11</span>
        <span class="p">},</span>
        <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">4</span>
        <span class="p">},</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;/&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">cvis</span><span class="o">.</span><span class="n">CalcVisitor</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span><span class="p">)</span>
</pre></div>


<h1 id="level-9-mixing-operators">Level 9 - Mixing operators<a class="headerlink" href="#level-9-mixing-operators" title="Permanent link">&para;</a></h1>
<p><em>"Don't cross the streams."</em></p>
<p>Ok, it's time to do some serious math. What happens if you mix sums and multiplications? Let's try it and see how our interpreter reacts. We already know that the lexer happily digests all the four symbols so we can head straight to the parser and add the following test to <code>tests/test_calc_parser.py</code></p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_parse_expression_with_term</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;2 + 3 * 4&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
        <span class="p">},</span>
        <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
            <span class="p">},</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">4</span>
            <span class="p">},</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>Chances are that this will fail miserably. Probably you have to rework a bit <code>parse_expression()</code> as it is ignoring the new entry, <code>parse_term()</code>. Please note that <code>2 * 3 + 4</code> must give <code>10</code> according to the standard math rules, and not <code>14</code>. This happens because multiplication is performed before sum, and the order depends uniquely on the structure created by the parser, and not by the visitor (which is at this point a pretty dumb component).</p>
<p>Once the parser outputs the correct structure the visitor shouldn't have issues, as it is already behaving in a recursive way. If you want to check feel free to add relevant tests, however.</p>
<h1 id="level-10-parentheses">Level 10 - Parentheses<a class="headerlink" href="#level-10-parentheses" title="Permanent link">&para;</a></h1>
<p><em>"When nine hundred years old you reach, look as good you will not."</em></p>
<p><a href="https://en.wikipedia.org/wiki/Bracket#Parentheses">Parentheses</a>) are curved brackets used in mathematics to change the order of operations. As this part is pretty important I will spend some time on it, because the order of operations will be of concerns also when it comes to language operators, and not only when dealing with mathematical operations. As explained in the previous section almost everything at this point happens in the parser, as the resulting structure that we will give to the visitor is the one that rules the precedence of operations.</p>
<p>Let's start to check that the lexer understands the parentheses</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_get_tokens_understands_parentheses</span><span class="p">():</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">clex</span><span class="o">.</span><span class="n">CalcLexer</span><span class="p">()</span>

    <span class="n">l</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;3 * ( 5 + 7 )&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">l</span><span class="o">.</span><span class="n">get_tokens</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">INTEGER</span><span class="p">,</span> <span class="s1">&#39;3&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">,</span> <span class="s1">&#39;(&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">INTEGER</span><span class="p">,</span> <span class="s1">&#39;5&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">INTEGER</span><span class="p">,</span> <span class="s1">&#39;7&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">LITERAL</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">EOL</span><span class="p">),</span>
        <span class="n">token</span><span class="o">.</span><span class="n">Token</span><span class="p">(</span><span class="n">clex</span><span class="o">.</span><span class="n">EOF</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div>


<p>As our lexer is pretty open-minded it shouldn't raise any objections and happily pass the test (why?). </p>
<p>The parser is not that forgiving, however, and I bet it will make a fuss. Let's try and feed it with some simple expression with parentheses</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_parse_expression_with_parentheses</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;(2 + 3)&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
        <span class="p">},</span>
        <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
        <span class="p">},</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>To make this test pass my suggestion is to introduce a <code>parse_factor()</code> method, where the term <em>factor</em> encompasses both the integers and the expressions between parentheses. In the latter case obviously, you will need to call <code>parse_expression()</code>, which somehow breaks the hierarchical structure of methods in the parser.</p>
<h1 id="level-11-priorities">Level 11 - Priorities<a class="headerlink" href="#level-11-priorities" title="Permanent link">&para;</a></h1>
<p><em>"You got issues, Quill."</em></p>
<p>As parentheses have been introduced to change the default priority rules between operators we need to be sure that this happens. We can test is very simply with this code</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_parse_parentheses_change_priority</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;(2 + 3) * 4&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_expression</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
            <span class="p">},</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
            <span class="p">},</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
            <span class="p">}</span>
        <span class="p">},</span>
        <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">4</span>
        <span class="p">},</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;*&#39;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>Now when your parser passes this test you have a full-fledged calculator that supports parentheses. Make sure to test the new features in the CLI. Does multiple parentheses work? Why?</p>
<h1 id="level-12-unary-operators">Level 12 - Unary operators<a class="headerlink" href="#level-12-unary-operators" title="Permanent link">&para;</a></h1>
<p><em>"There can be only one!"</em></p>
<p>Now it's time to introduce unary operators, which are very important in programming languages. Just think at <code>not x</code> and you will immediately understand why you need them. Unary operators do not fit in the current structure of our interpreter as the parser is always expecting either an integer or a parentheses as the first token.</p>
<p>Let's first write a test for the most simple unary operator, which is a minus (as in <code>-2</code>). Remember that we are testing the parser here, as the lexer is already able to parse the minus sign.</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_parse_factor_supports_unary_operator</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;-5&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_factor</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;unary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span>
        <span class="p">},</span>
        <span class="s1">&#39;content&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">5</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>When your parser passes this test we have to make sure that the unary minus can be applied also to expressions between parentheses</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_parse_factor_supports_negative_expressions</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;-(2 + 3)&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_factor</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;unary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span>
        <span class="p">},</span>
        <span class="s1">&#39;content&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
            <span class="p">},</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
            <span class="p">},</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>Once the parser is able to pass these two tests we are confident that the unary minus can be used in front of all the basic elements of our expressions. At this point it is time to execute the unary expressions produced by the parsing layer, so include this test for the visitor</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_visitor_unary_minus</span><span class="p">():</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;unary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span>
        <span class="p">},</span>
        <span class="s1">&#39;content&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
            <span class="p">},</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
            <span class="p">},</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">cvis</span><span class="o">.</span><span class="n">CalcVisitor</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span><span class="p">)</span>
</pre></div>


<p>Change the visitor to pass this test and you can go straight to the CLI and start using negative numbers or negative expressions. Can you execute something like <code>--2</code> (minus minus 2)? What is the result? Why?</p>
<p>Now let's go back to the parser and ensure that the unary plus can be used as well. This is the test</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_parse_factor_supports_unary_plus</span><span class="p">():</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">cpar</span><span class="o">.</span><span class="n">CalcParser</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;+(2 + 3)&quot;</span><span class="p">)</span>

    <span class="n">node</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_factor</span><span class="p">()</span>

    <span class="k">assert</span> <span class="n">node</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;unary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
        <span class="p">},</span>
        <span class="s1">&#39;content&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
            <span class="p">},</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
            <span class="p">},</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>and the code should be trivial, as you already manage the unary minus. The relative test for the visitor is</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">test_visitor_unary_plus</span><span class="p">():</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;unary&#39;</span><span class="p">,</span>
        <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
        <span class="p">},</span>
        <span class="s1">&#39;content&#39;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;binary&#39;</span><span class="p">,</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">2</span>
            <span class="p">},</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;integer&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mi">3</span>
            <span class="p">},</span>
            <span class="s1">&#39;operator&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;literal&#39;</span><span class="p">,</span>
                <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">cvis</span><span class="o">.</span><span class="n">CalcVisitor</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">v</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;integer&#39;</span><span class="p">)</span>
</pre></div>


<p>Once your code passes all the tests head to the CLI and try to run something like <code>-+--++-3</code>. Does it work?</p>
<h1 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h1>
<p>That's all for this time. If you feel brave or do not like to wait for the next post go and try adding new operators! Next issue will cover variables, assignments and postfix-operators like the power operation (<code>2^3</code>). I will also publish my solution to the tests presented here before moving on.</p>
<h1 id="titles">Titles<a class="headerlink" href="#titles" title="Permanent link">&para;</a></h1>
<p>The section quotes come from some good films: "Aliens" (1986), "Ghostbusters" (1984), "Return of the Jedi" (1983), "Guardians of the Galaxy" (2014), "Highlander" (1986).</p>
<h1 id="updates">Updates<a class="headerlink" href="#updates" title="Permanent link">&para;</a></h1>
<p>2017-12-24: <code>test_parse_term_with_multiple_operations</code> has been changed after Victor Uriarte spotted an error in the tree construction. See the updates section of the first post in the series for a full explanation of the issue.</p>
<h1 id="feedback">Feedback<a class="headerlink" href="#feedback" title="Permanent link">&para;</a></h1>
<p>Feel free to reach me on <a href="https://twitter.com/thedigicat">Twitter</a> if you have questions. The <a href="https://github.com/TheDigitalCatOnline/thedigitalcatonline.github.com/issues">GitHub issues</a> page is the best place to submit corrections.</p>
    </section>

    <section id="related">

        <h1>Part 3 of the A game of tokens series</h1>
        <div class="box">
            <h5>Previous articles</h5>
            <ul>
                <li><a href="/blog/2017/05/09/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-1/">A game of tokens: write an interpreter in Python with TDD - Part 1</a></li>
                <li><a href="/blog/2017/07/12/a-game-of-tokens-solution-part-1/">A game of tokens: solution - Part 1</a></li>
            </ul>
        
            <h5>Next articles</h5>
            <ul>
                <li><a href="/blog/2017/10/17/a-game-of-tokens-solution-part-2/">A game of tokens: solution - Part 2</a></li>
                <li><a href="/blog/2017/10/31/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-3/">A game of tokens: write an interpreter in Python with TDD - Part 3</a></li>
                <li><a href="/blog/2017/10/31/a-game-of-tokens-solution-part-3/">A game of tokens: solution - Part 3</a></li>
                <li><a href="/blog/2018/06/02/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-4/">A game of tokens: write an interpreter in Python with TDD - Part 4</a></li>
                <li><a href="/blog/2018/06/02/a-game-of-tokens-solution-part-4/">A game of tokens: solution - Part 4</a></li>
            </ul>
        </div>
    </section>



    <!-- </article> -->

						</div>
					</div>

				<!-- Sidebar -->
					<div id="sidebar">
<div class="inner">
    <!-- Menu -->
        <nav id="menu">
            <header class="major">
                <h2>Menu</h2>
            </header>
<ul>
    <li><a href="/index.html">Homepage</a></li>
    <li><a href="/pages/about.html">About</a></li>
    <li><a href="/archives/index.html">Archives</a></li>
    <li>
        <span class="opener">Categories</span>
        <ul>
            <li><a href="/category/programming/">Programming</a></li>
            <li><a href="/category/projects/">Projects</a></li>
            <li><a href="/category/retro/">Retro</a></li>
        </ul>
    </li>
</ul>        </nav>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Feeds</h2>
            </header>
<ul class="list-clean">
    <li><a href="/atom.xml"><i class="fa fa-rss"></i> All posts</a></li>


    <li><a href="/category/programming/atom.xml"><i class="fa fa-rss"></i> All posts in category: Programming</a></li>
</ul>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Tags</h2>
            </header>
<ul class="list-inline list-clean" id="tags-side">
    <li class="tag font-size-3">
        <a href="/categories/algorithms/">algorithms</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/amiga/">amiga</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/amqp/">AMQP</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/architectures/">architectures</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/assembly/">assembly</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/c/">C</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/clojure/">Clojure</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/compilers/">compilers</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/concurrent-programming/">concurrent programming</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/cryptography/">cryptography</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/decorators/">decorators</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/django/">Django</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/erlang/">Erlang</a>
    </li>
    <li class="tag font-size-1">
        <a href="/categories/functional-programming/">functional programming</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/generators/">generators</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/git/">Git</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/m68000/">M68000</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/metaclasses/">metaclasses</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/metaprogramming/">metaprogramming</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/notebook/">Notebook</a>
    </li>
    <li class="tag font-size-1">
        <a href="/categories/oop/">OOP</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/operating-systems/">operating systems</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/pelican/">pelican</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/pika/">Pika</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/postage/">Postage</a>
    </li>
    <li class="tag font-size-1">
        <a href="/categories/python/">Python</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/python2/">Python2</a>
    </li>
    <li class="tag font-size-1">
        <a href="/categories/python3/">Python3</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/rabbitmq/">RabbitMQ</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/refactoring/">refactoring</a>
    </li>
    <li class="tag font-size-2">
        <a href="/categories/retroprogramming/">retroprogramming</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/rsa/">RSA</a>
    </li>
    <li class="tag font-size-1">
        <a href="/categories/scala/">Scala</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/ssh/">SSH</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/ssl/">SSL</a>
    </li>
    <li class="tag font-size-1">
        <a href="/categories/tdd/">TDD</a>
    </li>
    <li class="tag font-size-1">
        <a href="/categories/testing/">testing</a>
    </li>
    <li class="tag font-size-3">
        <a href="/categories/versioning/">versioning</a>
    </li>
    <li class="tag font-size-4">
        <a href="/categories/video/">video</a>
    </li>
</ul>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Other posts</h2>
            </header>
<div class="mini-posts">
    <article>
        <a href="/blog/2018/06/02/a-game-of-tokens-solution-part-4/" class="image"><img src="/images/a-game-of-tokens-solutions.jpg" alt="a-game-of-tokens-solutions" /></a>
        <p><strong>A game of tokens: solution - Part 4</strong> <a href="/blog/2018/06/02/a-game-of-tokens-solution-part-4/">Read</a></p> 
    </article>
    <article>
        <a href="/blog/2018/06/02/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-4/" class="image"><img src="/images/a-game-of-tokens.jpg" alt="a-game-of-tokens" /></a>
        <p><strong>A game of tokens: write an interpreter in Python with TDD - Part 4</strong> <a href="/blog/2018/06/02/a-game-of-tokens-write-an-interpreter-in-python-with-tdd-part-4/">Read</a></p> 
    </article>
    <article>
        <a href="/blog/2017/10/31/a-game-of-tokens-solution-part-3/" class="image"><img src="/images/a-game-of-tokens-solutions.jpg" alt="a-game-of-tokens-solutions" /></a>
        <p><strong>A game of tokens: solution - Part 3</strong> <a href="/blog/2017/10/31/a-game-of-tokens-solution-part-3/">Read</a></p> 
    </article>
</div>        </section>

    <!-- Section -->
        <section>
            <header class="major">
                <h2>Get in touch</h2>
            </header>
<ul class="contact">
    
    
    
    <li class="fa-twitter"><a href="https://twitter.com/thedigicat">Twitter</a></li>
    
    
    
    
    <li class="fa-github"><a href="https://github.com/TheDigitalCatOnline">GitHub</a></li>
    
</ul>        </section>

    <!-- Footer -->
        <footer id="footer">
            <p class="copyright">Editorial theme by: <a href="https://html5up.net">HTML5 UP</a>.</p>
            <p class="copyright">Cover picture by: <a href="https://pxhere.com/en/photo/1428515">An Min @ pxhere.com</a></p>
        </footer>

</div>					</div>

			</div>

		<!-- Scripts -->
			<script src="/theme/js/jquery.min.js"></script>
			<script src="/theme/js/browser.min.js"></script>
			<script src="/theme/js/breakpoints.min.js"></script>
            <script src="/theme/js/packed.js?fa89ff81"></script>

	</body>
</html>